# java-filmorate

![Alt text](/documents/filmorate.png)


 ### Таблица genres
Хранит названия жанров \
__Поля__: id, название \
Ограничение длины для названия жанра - 64 символа

### Таблица mpa
Хранит названия рейтингов фильмов МРА \
__Поля__: id, название \
Ограничение длины для названия рейтинга - 5 символов

### Таблица films
Хранит список фильмов \
__Поля__: id, название, описание, id жанра, id рейтинга, дата релиза, продолжительность (в минутах) \
Ограничение длины для названия фильма - 128 символов \
Ограничение длины для описания фильма - 200 символов \
Связь таблиц mpa и films: один-ко-многим

### Таблица film_genre
Сопоставляет фильм и его жанр \
__Поля__: id фильма, id жанра \
Связь таблиц films и film_genre : один-ко-многим \
Связь таблиц genres и film_genre: один-ко-многим

__После просмотра вебинара стало понятно, что составной ключ (film_id и genre_id) не стоит без особой надобности использовать. Для того, чтобы добиться уникальности записи сразу по двум столбцам, используется unique constraint. Такое требование уникальности можно наложить как на один столбец, так и на группу, в нашем случае на два. Поле film_genre_id лучше вернуть, так как оно помогает разработчику легче ориентироваться в результатах запроса.__

### Таблица users
Хранит список пользователей \
__Поля__: id, логин, имя, email, дата рождения \
Ограничение длины для логина фильма - 32 символа \
Ограничение длины для имени - 128 символов \
Ограничение длины для email-а - 255 символов

### Таблица likes
Хранит информацию о повнавившихся пользователям фильмах \
__Поля__: id, id пользователя, id фильма \
Связь таблиц users и likes: один-ко-многим \
Связь таблиц films и likes: один-ко-многим

### Таблица friendship
Хранит информацию о друзьях пользователей \
__Поля__: id, id пользователя, id друга \
Дружба односторонняя, т.е. если пользователь `А` добавил в друзья (отправил заявку) пользователю `B`,
то пользователь `B` (приглашаемый) сразу добавляется в список друзей польльзователя `А` (инициатора),
но пользователь `А` добавляется в друзья польльзователю `B` только после принятия заявки. \
Строка вида: \
`<id строки> | A | B` \
(прим.: здесь и далее идентификаторы пользователей обозначены буквами)
означает, что пользователь `B` является другом пользователя `А`, но не наоборот \
При принятии заявки в друзья в таблицу добавится соответствующая запись: \
`<id строки> | B | A` \
что будет означать, что пользователь `А` также является другом пользователя `B` \
При удалении из друзей будет удалена одна запись из таблицы: пользователь остается в списке друзей у другого
пользователя, которого он удалил из своих друзей. \
Таким образом, подтвержденность дружбы между `А` и `B` определяется наличием двух записей: \
`<id строки> | A | B` \
и \
`<id строки> | B | A` \
Связь таблиц users и friends: один-ко-многим

#### Получить список друзей определенного пользователя (список подписок)
```sql
SELECT u.* 
FROM users u
JOIN friendship f ON u.id = f.friend_id
WHERE f.user_id = 0;  -- все на кого подписан пользователь 0
```

#### Получить список пользователей, у которых числится в друзьях заданный пользователь  (список подписчиков)
```sql
SELECT u.* 
FROM users u
JOIN friendship f ON u.id = f.user_id
WHERE f.friend_id = 1;
```

#### Проверить, является ли пользователь 0 другом относительно пользователя 2:
```sql
SELECT EXISTS (
    SELECT 1 FROM friendship
    WHERE user_id = 2 AND friend_id = 0
);
```
Соответственно, для определения симметричности дружбы (принятости заявки) между данными пользователями нужно проверить статус дружбы в обратную сторону.
